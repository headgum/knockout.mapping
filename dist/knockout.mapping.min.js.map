{"version":3,"sources":["knockout.mapping.js"],"names":["factory","require","exports","module","define","ko","Error","mapping","dependentObservables","visitedObjects","DEBUG","mappingProperty","realKoDependentObservable","dependentObservable","mappingNesting","recognizedRootProperties","emptyReturn","_defaultOptions","include","ignore","copy","observe","defaultOptions","extendObject","destination","source","key","destType","hasOwnProperty","getType","bothArrays","i","j","k","args","arguments","l","length","obj","res","push","unionArrays","merge","obj1","obj2","merged","fillOptions","rawOptions","otherOptions","options","property","Object","mergeArrays","mappedProperties","copiedProperties","a","b","undefined","utils","arrayGetDistinctValues","concat","withProxyDependentObservable","callback","localDO","read","owner","realDeferEvaluation","deferEvaluation","realIsPure","pure","isRemoved","realDependentObservable","DO","tmp","isWriteable","isWriteableObservable","wrapped","arrayRemoveItem","apply","write","val","_wrapper","__DO","wrap","fn","computed","result","ignorableIndexOf","array","item","ignoreIndices","mapKey","mappedItem","unwrapObservable","getItemByKey","filterArrayByKey","arrayMap","visitPropertiesOrArrayEntries","rootObject","visitorCallback","propertyName","canHaveProperties","object","type","escapePropertyNameComponent","indexer","replace","SimpleObjectLookup","keys","values","this","save","value","existingIndex","arrayIndexOf","get","ObjectLookup","findBucket","bucketKey","e","bucket","buckets","isMapped","viewModel","unwrapped","fromJS","jsObject","target","updateViewModel","mappedRootObject","parentName","parent","parentPropertyName","mappedParent","isArray","previousMapping","callbackParams","data","hasCreateCallback","create","Function","createCallback","Array","skip","hasUpdateCallback","update","updateCallback","params","observable","alreadyMapped","changes","hasKeyCallback","keyCallback","x","isObservable","observableArray","mappedRemove","valueOrPredicate","predicate","remove","mappedRemoveAll","arrayOfValues","arrayOfKeys","mappedDestroy","destroy","mappedDestroyAll","mappedIndexOf","mappedGet","mappedCreate","newValue","currentArrayKeys","sort","newArrayKeys","editScript","compareArrays","ignoreIndexOf","unwrappedRootObject","itemsByKey","optimizedKeys","index","newContents","passedOver","fullPropertyName","status","event","arrayChanged","arrayForEach","change","prevMappedProperty","retval","valueToWrite","hasCreateOrUpdateCallback","pop","fromJSON","jsonString","prototype","slice","call","parseJson","toJS","resetDefaultOptions","visitModel","toJSON","replacer","space","plainJavaScriptObject","stringifyJson","constructor","Date","escapedIndexer","propertyValue","unwrappedRootMappingProperty","previouslyMappedValue"],"mappings":"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","file":"knockout.mapping.min.js","sourcesContent":["(function(factory) {\n    'use strict';\n\n    /*jshint sub:true,curly:false*/\n    /*global ko,require,exports,define,module*/\n\n\n    if (typeof require === \"function\" && typeof exports === \"object\" && typeof module === \"object\") {\n        // CommonJS or Node: hard-coded dependency on \"knockout\"\n        // factory(require(\"tko\"), exports);\n        factory(require('@tko/build.reference/dist/build.reference'), exports);\n    } else if (typeof define === \"function\" && define[\"amd\"]) {\n        // AMD anonymous module with hard-coded dependency on \"knockout\"\n        define([\"tko\", \"exports\"], factory);\n        // factory(require('@tko/build.reference/dist/build.reference'), exports);\n    } else {\n        // <script> tag: use the global `ko` object, attaching a `mapping` property\n        if (typeof ko === 'undefined') {\n            throw new Error('Knockout is required, please ensure it is loaded before loading this mapping plug-in');\n        }\n        factory(ko, ko.mapping = {});\n    }\n}(function(ko, exports) {\n    /*jshint sub:true,curly:false*/\n    'use strict';\n\n    ko.mapping = exports;\n\n    var DEBUG = true;\n    var mappingProperty = \"__ko_mapping__\";\n    var realKoDependentObservable = ko.dependentObservable;\n    var mappingNesting = 0;\n    var dependentObservables;\n    var visitedObjects;\n    var recognizedRootProperties = [\"create\", \"update\", \"key\", \"arrayChanged\"];\n    var emptyReturn = {};\n\n    var _defaultOptions = {\n        include: [\"_destroy\"],\n        ignore: [],\n        copy: [],\n        observe: []\n    };\n    var defaultOptions = _defaultOptions;\n\n    function unionArrays() {\n        var args = arguments,\n            l = args.length,\n            obj = {},\n            res = [],\n            i, j, k;\n\n        while (l--) {\n            k = args[l];\n            i = k.length;\n\n            while (i--) {\n                j = k[i];\n                if (!obj[j]) {\n                    obj[j] = 1;\n                    res.push(j);\n                }\n            }\n        }\n\n        return res;\n    }\n\n    function extendObject(destination, source) {\n        var destType;\n\n        for (var key in source) {\n            if (source.hasOwnProperty(key) && source[key]) {\n                destType = exports.getType(destination[key]);\n                if (key && destination[key] && destType !== \"array\" && destType !== \"string\") {\n                    extendObject(destination[key], source[key]);\n                } else {\n                    var bothArrays = exports.getType(destination[key]) === \"array\" && exports.getType(source[key]) === \"array\";\n                    if (bothArrays) {\n                        destination[key] = unionArrays(destination[key], source[key]);\n                    } else {\n                        destination[key] = source[key];\n                    }\n                }\n            }\n        }\n    }\n\n    function merge(obj1, obj2) {\n        var merged = {};\n        extendObject(merged, obj1);\n        extendObject(merged, obj2);\n\n        return merged;\n    }\n\n    exports.isMapped = function(viewModel) {\n        var unwrapped = ko.utils.unwrapObservable(viewModel);\n        return unwrapped && unwrapped[mappingProperty];\n    };\n\n    exports.fromJS = function(jsObject /*, inputOptions, target*/ ) {\n        if (arguments.length === 0) {\n            throw new Error(\"When calling ko.fromJS, pass the object you want to convert.\");\n        }\n        try {\n            if (!mappingNesting) {\n                dependentObservables = [];\n                visitedObjects = new ObjectLookup();\n            }\n            mappingNesting++;\n\n            var options;\n            var target;\n\n            if (arguments.length === 2) {\n                if (arguments[1][mappingProperty]) {\n                    target = arguments[1];\n                } else {\n                    options = arguments[1];\n                }\n            }\n            if (arguments.length === 3) {\n                options = arguments[1];\n                target = arguments[2];\n            }\n\n            if (target) {\n                options = merge(options, target[mappingProperty]);\n            }\n            options = fillOptions(options);\n\n            var result = updateViewModel(target, jsObject, options);\n            if (target) {\n                result = target;\n            }\n\n            // Evaluate any dependent observables that were proxied.\n            // Do this after the model's observables have been created\n            if (!--mappingNesting) {\n                while (dependentObservables.length) {\n                    var DO = dependentObservables.pop();\n                    if (DO) {\n                        DO();\n                        // Move this magic property to the underlying dependent observable\n                        DO.__DO[\"throttleEvaluation\"] = DO[\"throttleEvaluation\"];\n                    }\n                }\n            }\n\n            // Save any new mapping options in the view model, so that updateFromJS can use them later.\n            result[mappingProperty] = merge(result[mappingProperty], options);\n\n            return result;\n        } catch (e) {\n            mappingNesting = 0;\n            throw e;\n        }\n    };\n\n    exports.fromJSON = function(jsonString /*, options, target*/ ) {\n        var args = Array.prototype.slice.call(arguments, 0);\n        args[0] = ko.utils.parseJson(jsonString);\n        return exports.fromJS.apply(this, args);\n    };\n\n    exports.toJS = function(rootObject, options) {\n        if (!defaultOptions) exports.resetDefaultOptions();\n\n        if (arguments.length === 0) throw new Error(\"When calling ko.mapping.toJS, pass the object you want to convert.\");\n        if (exports.getType(defaultOptions.ignore) !== \"array\") throw new Error(\"ko.mapping.defaultOptions().ignore should be an array.\");\n        if (exports.getType(defaultOptions.include) !== \"array\") throw new Error(\"ko.mapping.defaultOptions().include should be an array.\");\n        if (exports.getType(defaultOptions.copy) !== \"array\") throw new Error(\"ko.mapping.defaultOptions().copy should be an array.\");\n\n        // Merge in the options used in fromJS\n        options = fillOptions(options, rootObject[mappingProperty]);\n\n        // We just unwrap everything at every level in the object graph\n        return exports.visitModel(rootObject, function(x) {\n            return ko.utils.unwrapObservable(x);\n        }, options);\n    };\n\n    exports.toJSON = function(rootObject, options, replacer, space) {\n        var plainJavaScriptObject = exports.toJS(rootObject, options);\n        return ko.utils.stringifyJson(plainJavaScriptObject, replacer, space);\n    };\n\n    exports.defaultOptions = function() {\n        if (arguments.length > 0) {\n            defaultOptions = arguments[0];\n        } else {\n            return defaultOptions;\n        }\n    };\n\n    exports.resetDefaultOptions = function() {\n        defaultOptions = {\n            include: _defaultOptions.include.slice(0),\n            ignore: _defaultOptions.ignore.slice(0),\n            copy: _defaultOptions.copy.slice(0),\n            observe: _defaultOptions.observe.slice(0)\n        };\n    };\n\n    exports.getType = function(x) {\n        if ((x) && (typeof(x) === \"object\")) {\n            if (x.constructor === Date) return \"date\";\n            if (x.constructor === Array) return \"array\";\n        }\n        return typeof x;\n    };\n\n    function fillOptions(rawOptions, otherOptions) {\n        var options = merge({}, rawOptions);\n\n        // Move recognized root-level properties into a root namespace\n        for (var i = recognizedRootProperties.length - 1; i >= 0; i--) {\n            var property = recognizedRootProperties[i];\n\n            // Carry on, unless this property is present\n            if (!options[property]) continue;\n\n            // Move the property into the root namespace\n            if (!(options[\"\"] instanceof Object)) options[\"\"] = {};\n            options[\"\"][property] = options[property];\n            delete options[property];\n        }\n\n        if (otherOptions) {\n            options.ignore = mergeArrays(otherOptions.ignore, options.ignore);\n            options.include = mergeArrays(otherOptions.include, options.include);\n            options.copy = mergeArrays(otherOptions.copy, options.copy);\n            options.observe = mergeArrays(otherOptions.observe, options.observe);\n        }\n        options.ignore = mergeArrays(options.ignore, defaultOptions.ignore);\n        options.include = mergeArrays(options.include, defaultOptions.include);\n        options.copy = mergeArrays(options.copy, defaultOptions.copy);\n        options.observe = mergeArrays(options.observe, defaultOptions.observe);\n\n        options.mappedProperties = options.mappedProperties || {};\n        options.copiedProperties = options.copiedProperties || {};\n        return options;\n    }\n\n    function mergeArrays(a, b) {\n        if (a === undefined) {\n            a = [];\n        } else if (exports.getType(a) !== \"array\") {\n            a = [a];\n        }\n\n        if (b === undefined) {\n            b = [];\n        } else if (exports.getType(b) !== \"array\") {\n            b = [b];\n        }\n\n        return ko.utils.arrayGetDistinctValues(a.concat(b));\n    }\n\n    // When using a 'create' callback, we proxy the dependent observable so that it doesn't immediately evaluate on creation.\n    // The reason is that the dependent observables in the user-specified callback may contain references to properties that have not been mapped yet.\n    function withProxyDependentObservable(dependentObservables, callback) {\n        var localDO = ko.dependentObservable;\n        ko.dependentObservable = function(read, owner, options) {\n            options = options || {};\n\n            if (read && typeof read === \"object\") { // mirrors condition in knockout implementation of DO's\n                options = read;\n            }\n\n            var realDeferEvaluation = options.deferEvaluation;\n            var realIsPure = options.pure;\n\n            var isRemoved = false;\n\n            // We wrap the original dependent observable so that we can remove it from the 'dependentObservables' list we need to evaluate after mapping has\n            // completed if the user already evaluated the DO themselves in the meantime.\n            var wrap = function(DO) {\n                // Temporarily revert ko.dependentObservable, since it is used in ko.isWriteableObservable\n                var tmp = ko.dependentObservable;\n                ko.dependentObservable = realKoDependentObservable;\n                var isWriteable = ko.isWriteableObservable(DO);\n                ko.dependentObservable = tmp;\n\n                var wrapped = realKoDependentObservable({\n                    read: function() {\n                        if (!isRemoved) {\n                            ko.utils.arrayRemoveItem(dependentObservables, DO);\n                            isRemoved = true;\n                        }\n                        return DO.apply(DO, arguments);\n                    },\n                    write: isWriteable && function(val) {\n                        return DO(val);\n                    },\n                    deferEvaluation: true\n                });\n                if (DEBUG) wrapped._wrapper = true;\n                wrapped.__DO = DO;\n                return wrapped;\n            };\n\n            options.deferEvaluation = true; // will either set for just options, or both read/options.\n            var realDependentObservable = realKoDependentObservable(read, owner, options);\n\n            if (!realDeferEvaluation && !realIsPure) {\n                realDependentObservable = wrap(realDependentObservable);\n                dependentObservables.push(realDependentObservable);\n            }\n\n            return realDependentObservable;\n        };\n        ko.dependentObservable.fn = realKoDependentObservable.fn;\n        ko.computed = ko.dependentObservable;\n        var result = callback();\n        ko.dependentObservable = localDO;\n        ko.computed = ko.dependentObservable;\n        return result;\n    }\n\n    function updateViewModel(mappedRootObject, rootObject, options, parentName, parent, parentPropertyName, mappedParent) {\n        var isArray = exports.getType(ko.utils.unwrapObservable(rootObject)) === \"array\";\n\n        parentPropertyName = parentPropertyName || \"\";\n\n        // If this object was already mapped previously, take the options from there and merge them with our existing ones.\n        if (exports.isMapped(mappedRootObject)) {\n            var previousMapping = ko.utils.unwrapObservable(mappedRootObject)[mappingProperty];\n            options = merge(previousMapping, options);\n        }\n\n        var callbackParams = {\n            data: rootObject,\n            parent: mappedParent || parent\n        };\n\n        var hasCreateCallback = function() {\n            return options[parentName] && options[parentName].create instanceof Function;\n        };\n\n        var createCallback = function(data) {\n            return withProxyDependentObservable(dependentObservables, function() {\n\n                if (ko.utils.unwrapObservable(parent) instanceof Array) {\n                    return options[parentName].create({\n                        data: data || callbackParams.data,\n                        parent: callbackParams.parent,\n                        skip: emptyReturn\n                    });\n                } else {\n                    return options[parentName].create({\n                        data: data || callbackParams.data,\n                        parent: callbackParams.parent\n                    });\n                }\n            });\n        };\n\n        var hasUpdateCallback = function() {\n            return options[parentName] && options[parentName].update instanceof Function;\n        };\n\n        var updateCallback = function(obj, data) {\n            var params = {\n                data: data || callbackParams.data,\n                parent: callbackParams.parent,\n                target: ko.utils.unwrapObservable(obj)\n            };\n\n            if (ko.isWriteableObservable(obj)) {\n                params.observable = obj;\n            }\n\n            return options[parentName].update(params);\n        };\n\n        var alreadyMapped = visitedObjects.get(rootObject);\n        if (alreadyMapped) {\n            return alreadyMapped;\n        }\n\n        parentName = parentName || \"\";\n\n        if (!isArray) {\n            // For atomic types, do a direct update on the observable\n            if (!canHaveProperties(rootObject)) {\n                switch (exports.getType(rootObject)) {\n                    case \"function\":\n                        if (hasUpdateCallback()) {\n                            if (ko.isWriteableObservable(rootObject)) {\n                                rootObject(updateCallback(rootObject));\n                                mappedRootObject = rootObject;\n                            } else {\n                                mappedRootObject = updateCallback(rootObject);\n                            }\n                        } else {\n                            mappedRootObject = rootObject;\n                        }\n                        break;\n                    default:\n                        if (ko.isWriteableObservable(mappedRootObject)) {\n                            var valueToWrite;\n                            if (hasUpdateCallback()) {\n                                valueToWrite = updateCallback(mappedRootObject);\n                                mappedRootObject(valueToWrite);\n                                return valueToWrite;\n                            } else {\n                                valueToWrite = ko.utils.unwrapObservable(rootObject);\n                                mappedRootObject(valueToWrite);\n                                return valueToWrite;\n                            }\n                        } else {\n                            var hasCreateOrUpdateCallback = hasCreateCallback() || hasUpdateCallback();\n\n                            if (hasCreateCallback()) {\n                                mappedRootObject = createCallback();\n                            } else {\n                                mappedRootObject = ko.observable(ko.utils.unwrapObservable(rootObject));\n                            }\n\n                            if (hasUpdateCallback()) {\n                                mappedRootObject(updateCallback(mappedRootObject));\n                            }\n\n                            if (hasCreateOrUpdateCallback) return mappedRootObject;\n                        }\n                }\n\n            } else {\n                mappedRootObject = ko.utils.unwrapObservable(mappedRootObject);\n                if (!mappedRootObject) {\n                    if (hasCreateCallback()) {\n                        var result = createCallback();\n\n                        if (hasUpdateCallback()) {\n                            result = updateCallback(result);\n                        }\n                        return result;\n                    } else {\n                        if (hasUpdateCallback()) {\n                            //Removed ambiguous parameter result\n                            return updateCallback();\n                        }\n                        mappedRootObject = {};\n                    }\n                }\n\n                if (hasUpdateCallback()) {\n                    mappedRootObject = updateCallback(mappedRootObject);\n                }\n\n                visitedObjects.save(rootObject, mappedRootObject);\n                if (hasUpdateCallback()) return mappedRootObject;\n\n                // For non-atomic types, visit all properties and update recursively\n                visitPropertiesOrArrayEntries(rootObject, function(indexer) {\n                    var fullPropertyName = parentPropertyName.length ? parentPropertyName + \".\" + escapePropertyNameComponent(indexer) : escapePropertyNameComponent(indexer);\n\n                    if (ko.utils.arrayIndexOf(options.ignore, fullPropertyName) !== -1) {\n                        return;\n                    }\n\n                    if (ko.utils.arrayIndexOf(options.copy, fullPropertyName) !== -1) {\n                        mappedRootObject[indexer] = rootObject[indexer];\n                        return;\n                    }\n\n                    if (typeof rootObject[indexer] !== \"object\" && exports.getType(rootObject[indexer]) !== \"array\" && options.observe.length > 0 && ko.utils.arrayIndexOf(options.observe, fullPropertyName) === -1) {\n                        mappedRootObject[indexer] = rootObject[indexer];\n                        options.copiedProperties[fullPropertyName] = true;\n                        return;\n                    }\n\n                    // In case we are adding an already mapped property, fill it with the previously mapped property value to prevent recursion.\n                    // If this is a property that was generated by fromJS, we should use the options specified there\n                    var prevMappedProperty = visitedObjects.get(rootObject[indexer]);\n                    var retval = updateViewModel(mappedRootObject[indexer], rootObject[indexer], options, indexer, mappedRootObject, fullPropertyName, mappedRootObject);\n                    var value = prevMappedProperty || retval;\n\n                    if (options.observe.length > 0 && ko.utils.arrayIndexOf(options.observe, fullPropertyName) === -1) {\n                        mappedRootObject[indexer] = ko.utils.unwrapObservable(value);\n                        options.copiedProperties[fullPropertyName] = true;\n                        return;\n                    }\n\n                    if (ko.isWriteableObservable(mappedRootObject[indexer])) {\n                        value = ko.utils.unwrapObservable(value);\n                        if (mappedRootObject[indexer]() !== value) {\n                            mappedRootObject[indexer](value);\n                        }\n                    } else {\n                        value = mappedRootObject[indexer] === undefined ? value : ko.utils.unwrapObservable(value);\n                        mappedRootObject[indexer] = value;\n                    }\n\n                    options.mappedProperties[fullPropertyName] = true;\n                });\n            }\n        } else { //mappedRootObject is an array\n            var changes = [];\n\n            var hasKeyCallback = false;\n            var keyCallback = function(x) {\n                return x;\n            };\n            if (options[parentName] && options[parentName].key) {\n                keyCallback = options[parentName].key;\n                hasKeyCallback = true;\n            }\n\n            if (!ko.isObservable(mappedRootObject)) {\n                // When creating the new observable array, also add a bunch of utility functions that take the 'key' of the array items into account.\n                mappedRootObject = ko.observableArray([]);\n\n                mappedRootObject.mappedRemove = function(valueOrPredicate) {\n                    var predicate = typeof valueOrPredicate === \"function\" ? valueOrPredicate : function(value) {\n                        return value === keyCallback(valueOrPredicate);\n                    };\n                    return mappedRootObject.remove(function(item) {\n                        return predicate(keyCallback(item));\n                    });\n                };\n\n                mappedRootObject.mappedRemoveAll = function(arrayOfValues) {\n                    var arrayOfKeys = filterArrayByKey(arrayOfValues, keyCallback);\n                    return mappedRootObject.remove(function(item) {\n                        return ko.utils.arrayIndexOf(arrayOfKeys, keyCallback(item)) !== -1;\n                    });\n                };\n\n                mappedRootObject.mappedDestroy = function(valueOrPredicate) {\n                    var predicate = typeof valueOrPredicate === \"function\" ? valueOrPredicate : function(value) {\n                        return value === keyCallback(valueOrPredicate);\n                    };\n                    return mappedRootObject.destroy(function(item) {\n                        return predicate(keyCallback(item));\n                    });\n                };\n\n                mappedRootObject.mappedDestroyAll = function(arrayOfValues) {\n                    var arrayOfKeys = filterArrayByKey(arrayOfValues, keyCallback);\n                    return mappedRootObject.destroy(function(item) {\n                        return ko.utils.arrayIndexOf(arrayOfKeys, keyCallback(item)) !== -1;\n                    });\n                };\n\n                mappedRootObject.mappedIndexOf = function(item) {\n                    var keys = filterArrayByKey(mappedRootObject(), keyCallback);\n                    var key = keyCallback(item);\n                    return ko.utils.arrayIndexOf(keys, key);\n                };\n\n                mappedRootObject.mappedGet = function(item) {\n                    return mappedRootObject()[mappedRootObject.mappedIndexOf(item)];\n                };\n\n                mappedRootObject.mappedCreate = function(value) {\n                    if (mappedRootObject.mappedIndexOf(value) !== -1) {\n                        throw new Error(\"There already is an object with the key that you specified.\");\n                    }\n                    var item = hasCreateCallback() ? createCallback(value) : value;\n                    if (hasUpdateCallback()) {\n                        var newValue = updateCallback(item, value);\n                        if (ko.isWriteableObservable(item)) {\n                            item(newValue);\n                        } else {\n                            item = newValue;\n                        }\n                    }\n                    mappedRootObject.push(item);\n                    return item;\n                };\n            }\n\n            var currentArrayKeys = filterArrayByKey(ko.utils.unwrapObservable(mappedRootObject), keyCallback).sort();\n            var newArrayKeys = filterArrayByKey(rootObject, keyCallback);\n            if (hasKeyCallback) newArrayKeys.sort();\n            var editScript = ko.utils.compareArrays(currentArrayKeys, newArrayKeys);\n\n            var ignoreIndexOf = {};\n\n            var i, j, key;\n\n            var unwrappedRootObject = ko.utils.unwrapObservable(rootObject);\n            var itemsByKey = {};\n            var optimizedKeys = true;\n            for (i = 0, j = unwrappedRootObject.length; i < j; i++) {\n                key = keyCallback(unwrappedRootObject[i]);\n                if (key === undefined || key instanceof Object) {\n                    optimizedKeys = false;\n                    break;\n                }\n                itemsByKey[key] = unwrappedRootObject[i];\n            }\n\n            var newContents = [];\n            var passedOver = 0;\n            var item, index;\n\n            for (i = 0, j = editScript.length; i < j; i++) {\n                key = editScript[i];\n                var mappedItem;\n                var fullPropertyName = parentPropertyName + \"[\" + escapePropertyNameComponent(i) + \"]\";\n\n                switch (key.status) {\n                    case \"added\":\n                        item = optimizedKeys ? itemsByKey[key.value] : getItemByKey(ko.utils.unwrapObservable(rootObject), key.value, keyCallback);\n                        mappedItem = updateViewModel(undefined, item, options, parentName, mappedRootObject, fullPropertyName, parent);\n                        if (!hasCreateCallback()) {\n                            mappedItem = ko.utils.unwrapObservable(mappedItem);\n                        }\n\n                        index = ignorableIndexOf(ko.utils.unwrapObservable(rootObject), item, ignoreIndexOf);\n\n                        if (mappedItem === emptyReturn) {\n                            passedOver++;\n                        } else {\n                            newContents[index - passedOver] = mappedItem;\n                        }\n\n                        ignoreIndexOf[index] = true;\n                        break;\n                    case \"retained\":\n                        item = optimizedKeys ? itemsByKey[key.value] : getItemByKey(ko.utils.unwrapObservable(rootObject), key.value, keyCallback);\n                        mappedItem = getItemByKey(mappedRootObject, key.value, keyCallback);\n                        updateViewModel(mappedItem, item, options, parentName, mappedRootObject, fullPropertyName, parent);\n\n                        index = ignorableIndexOf(ko.utils.unwrapObservable(rootObject), item, ignoreIndexOf);\n                        newContents[index] = mappedItem;\n                        ignoreIndexOf[index] = true;\n                        break;\n                    case \"deleted\":\n                        mappedItem = getItemByKey(mappedRootObject, key.value, keyCallback);\n                        break;\n                }\n\n                changes.push({\n                    event: key.status,\n                    item: mappedItem\n                });\n            }\n\n            mappedRootObject(newContents);\n\n            if (options[parentName] && options[parentName].arrayChanged) {\n                ko.utils.arrayForEach(changes, function(change) {\n                    options[parentName].arrayChanged(change.event, change.item);\n                });\n            }\n        }\n\n        return mappedRootObject;\n    }\n\n    function ignorableIndexOf(array, item, ignoreIndices) {\n        for (var i = 0, j = array.length; i < j; i++) {\n            if (ignoreIndices[i] === true) continue;\n            if (array[i] === item) return i;\n        }\n        return null;\n    }\n\n    function mapKey(item, callback) {\n        var mappedItem;\n        if (callback) mappedItem = callback(item);\n        if (exports.getType(mappedItem) === \"undefined\") mappedItem = item;\n\n        return ko.utils.unwrapObservable(mappedItem);\n    }\n\n    function getItemByKey(array, key, callback) {\n        array = ko.utils.unwrapObservable(array);\n        for (var i = 0, j = array.length; i < j; i++) {\n            var item = array[i];\n            if (mapKey(item, callback) === key) return item;\n        }\n\n        throw new Error(\"When calling ko.update*, the key '\" + key + \"' was not found!\");\n    }\n\n    function filterArrayByKey(array, callback) {\n        return ko.utils.arrayMap(ko.utils.unwrapObservable(array), function(item) {\n            if (callback) {\n                return mapKey(item, callback);\n            } else {\n                return item;\n            }\n        });\n    }\n\n    function visitPropertiesOrArrayEntries(rootObject, visitorCallback) {\n        if (exports.getType(rootObject) === \"array\") {\n            for (var i = 0; i < rootObject.length; i++)\n                visitorCallback(i);\n        } else {\n            for (var propertyName in rootObject) {\n                if (rootObject.hasOwnProperty(propertyName)) {\n                    visitorCallback(propertyName);\n                }\n            }\n        }\n    }\n\n    function canHaveProperties(object) {\n        if (object === null) {\n            return false;\n        }\n        var type = exports.getType(object);\n        return (type === \"object\") || (type === \"array\");\n    }\n\n    // Based on the parentName, this creates a fully classified name of a property\n\n    function getPropertyName(parentName, parent, indexer) {\n        var propertyName = parentName || \"\";\n        if (exports.getType(parent) === \"array\") {\n            if (parentName) {\n                propertyName += \"[\" + escapePropertyNameComponent(indexer) + \"]\";\n            }\n        } else {\n            if (parentName) {\n                propertyName += \".\";\n            }\n            propertyName += escapePropertyNameComponent(indexer);\n        }\n        return propertyName;\n    }\n\n    function escapePropertyNameComponent(indexer) {\n        var escapedIndexer = ('' + indexer)\n            .replace(/~/g, '~~')\n            .replace(/\\[/g, '~[')\n            .replace(/]/g, '~]')\n            .replace(/\\./g, '~.');\n        return escapedIndexer;\n    }\n\n\n    exports.visitModel = function(rootObject, callback, options) {\n        options = options || {};\n        options.visitedObjects = options.visitedObjects || new ObjectLookup();\n\n        var mappedRootObject;\n        var unwrappedRootObject = ko.utils.unwrapObservable(rootObject);\n\n        if (!canHaveProperties(unwrappedRootObject)) {\n            return callback(rootObject, options.parentName);\n        } else {\n            options = fillOptions(options, unwrappedRootObject[mappingProperty]);\n\n            // Only do a callback, but ignore the results\n            callback(rootObject, options.parentName);\n            mappedRootObject = exports.getType(unwrappedRootObject) === \"array\" ? [] : {};\n        }\n\n        options.visitedObjects.save(rootObject, mappedRootObject);\n\n        var parentName = options.parentName;\n        visitPropertiesOrArrayEntries(unwrappedRootObject, function(indexer) {\n            var escapedIndexer = escapePropertyNameComponent(indexer);\n            if (options.ignore && ko.utils.arrayIndexOf(options.ignore, escapedIndexer) !== -1) return;\n\n            var propertyValue = unwrappedRootObject[indexer];\n            options.parentName = getPropertyName(parentName, unwrappedRootObject, indexer);\n\n            // If we don't want to explicitly copy the unmapped property...\n            if (ko.utils.arrayIndexOf(options.copy, escapedIndexer) === -1) {\n                // ...find out if it's a property we want to explicitly include\n                if (ko.utils.arrayIndexOf(options.include, escapedIndexer) === -1) {\n                    // The mapped properties object contains all the properties that were part of the original object.\n                    // If a property does not exist, and it is not because it is part of an array (e.g. \"myProp[3]\"), then it should not be unmapped.\n                    var unwrappedRootMappingProperty = unwrappedRootObject[mappingProperty];\n                    if (unwrappedRootMappingProperty) {\n                        var mappedProperties = unwrappedRootMappingProperty.mappedProperties;\n                        if (mappedProperties && !mappedProperties[escapedIndexer]) {\n                            var copiedProperties = unwrappedRootMappingProperty.copiedProperties;\n                            if (copiedProperties && !copiedProperties[escapedIndexer] && (exports.getType(unwrappedRootObject) !== \"array\")) {\n                                return;\n                            }\n                        }\n                    }\n                }\n            }\n\n            switch (exports.getType(ko.utils.unwrapObservable(propertyValue))) {\n                case \"object\":\n                case \"array\":\n                case \"undefined\":\n                    var previouslyMappedValue = options.visitedObjects.get(propertyValue);\n                    mappedRootObject[indexer] = (exports.getType(previouslyMappedValue) !== \"undefined\") ? previouslyMappedValue : exports.visitModel(propertyValue, callback, options);\n                    break;\n                default:\n                    mappedRootObject[indexer] = callback(propertyValue, options.parentName);\n            }\n        });\n\n        return mappedRootObject;\n    };\n\n    function SimpleObjectLookup() {\n        var keys = [];\n        var values = [];\n        this.save = function(key, value) {\n            var existingIndex = ko.utils.arrayIndexOf(keys, key);\n            if (existingIndex >= 0) values[existingIndex] = value;\n            else {\n                keys.push(key);\n                values.push(value);\n            }\n        };\n        this.get = function(key) {\n            var existingIndex = ko.utils.arrayIndexOf(keys, key);\n            var value = (existingIndex >= 0) ? values[existingIndex] : undefined;\n            return value;\n        };\n    }\n\n    function ObjectLookup() {\n        var buckets = {};\n\n        var findBucket = function(key) {\n            var bucketKey;\n            try {\n                bucketKey = key; //JSON.stringify(key);\n            } catch (e) {\n                bucketKey = \"$$$\";\n            }\n\n            var bucket = buckets[bucketKey];\n            if (!buckets.hasOwnProperty(bucketKey)) {\n                bucket = new SimpleObjectLookup();\n                buckets[bucketKey] = bucket;\n            }\n            return bucket;\n        };\n\n        this.save = function(key, value) {\n            findBucket(key).save(key, value);\n        };\n        this.get = function(key) {\n            return findBucket(key).get(key);\n        };\n    }\n}));\n"]}