{"version":3,"sources":["knockout.mapping.js"],"names":["ko","exports","mapping","DEBUG","mappingProperty","realKoDependentObservable","dependentObservable","mappingNesting","dependentObservables","visitedObjects","recognizedRootProperties","emptyReturn","_defaultOptions","include","ignore","copy","observe","defaultOptions","unionArrays","args","arguments","l","length","obj","res","i","j","k","push","extendObject","destination","source","destType","key","hasOwnProperty","getType","bothArrays","merge","obj1","obj2","merged","fillOptions","rawOptions","otherOptions","options","property","Object","mergeArrays","mappedProperties","copiedProperties","a","b","undefined","utils","arrayGetDistinctValues","concat","withProxyDependentObservable","callback","localDO","read","owner","realDeferEvaluation","deferEvaluation","realIsPure","pure","isRemoved","wrap","DO","tmp","isWriteable","isWriteableObservable","wrapped","arrayRemoveItem","apply","write","val","_wrapper","__DO","realDependentObservable","fn","computed","result","updateViewModel","mappedRootObject","rootObject","parentName","parent","parentPropertyName","mappedParent","isArray","unwrapObservable","isMapped","previousMapping","callbackParams","data","hasCreateCallback","create","Function","createCallback","Array","skip","hasUpdateCallback","update","updateCallback","params","target","observable","alreadyMapped","get","canHaveProperties","valueToWrite","hasCreateOrUpdateCallback","save","visitPropertiesOrArrayEntries","indexer","fullPropertyName","escapePropertyNameComponent","arrayIndexOf","prevMappedProperty","retval","value","changes","hasKeyCallback","keyCallback","x","isObservable","observableArray","mappedRemove","valueOrPredicate","predicate","remove","item","mappedRemoveAll","arrayOfValues","arrayOfKeys","filterArrayByKey","mappedDestroy","destroy","mappedDestroyAll","mappedIndexOf","keys","mappedGet","mappedCreate","Error","newValue","currentArrayKeys","sort","newArrayKeys","editScript","compareArrays","ignoreIndexOf","unwrappedRootObject","itemsByKey","optimizedKeys","newContents","passedOver","index","mappedItem","status","getItemByKey","ignorableIndexOf","event","arrayChanged","arrayForEach","change","array","ignoreIndices","mapKey","arrayMap","visitorCallback","propertyName","object","type","getPropertyName","escapedIndexer","replace","SimpleObjectLookup","values","this","existingIndex","ObjectLookup","buckets","findBucket","bucketKey","e","bucket","viewModel","unwrapped","fromJS","jsObject","pop","fromJSON","jsonString","prototype","slice","call","parseJson","toJS","resetDefaultOptions","visitModel","toJSON","replacer","space","plainJavaScriptObject","stringifyJson","constructor","Date","propertyValue","unwrappedRootMappingProperty","previouslyMappedValue","factory","require"],"mappings":"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","file":"knockout.mapping.min.js","sourcesContent":["(function(factory) {\n    'use strict';\n\n    /*jshint sub:true,curly:false*/\n    /*global ko,require,exports,define,module*/\n\n    factory(require('@tko/build.reference/dist/build.reference'), exports);\n\n    // if (typeof require === \"function\" && typeof exports === \"object\" && typeof module === \"object\") {\n    //     // CommonJS or Node: hard-coded dependency on \"knockout\"\n    //     factory(require(\"tko\"), exports);\n    // } else if (typeof define === \"function\" && define[\"amd\"]) {\n    //     // AMD anonymous module with hard-coded dependency on \"knockout\"\n    //     define([\"tko\", \"exports\"], factory);\n    // } else {\n    //     // <script> tag: use the global `ko` object, attaching a `mapping` property\n    //     if (typeof ko === 'undefined') {\n    //         throw new Error('Knockout is required, please ensure it is loaded before loading this mapping plug-in');\n    //     }\n    //     factory(ko, ko.mapping = {});\n    // }\n}(function(ko, exports) {\n    /*jshint sub:true,curly:false*/\n    'use strict';\n\n    ko.mapping = exports;\n\n    var DEBUG = true;\n    var mappingProperty = \"__ko_mapping__\";\n    var realKoDependentObservable = ko.dependentObservable;\n    var mappingNesting = 0;\n    var dependentObservables;\n    var visitedObjects;\n    var recognizedRootProperties = [\"create\", \"update\", \"key\", \"arrayChanged\"];\n    var emptyReturn = {};\n\n    var _defaultOptions = {\n        include: [\"_destroy\"],\n        ignore: [],\n        copy: [],\n        observe: []\n    };\n    var defaultOptions = _defaultOptions;\n\n    function unionArrays() {\n        var args = arguments,\n            l = args.length,\n            obj = {},\n            res = [],\n            i, j, k;\n\n        while (l--) {\n            k = args[l];\n            i = k.length;\n\n            while (i--) {\n                j = k[i];\n                if (!obj[j]) {\n                    obj[j] = 1;\n                    res.push(j);\n                }\n            }\n        }\n\n        return res;\n    }\n\n    function extendObject(destination, source) {\n        var destType;\n\n        for (var key in source) {\n            if (source.hasOwnProperty(key) && source[key]) {\n                destType = exports.getType(destination[key]);\n                if (key && destination[key] && destType !== \"array\" && destType !== \"string\") {\n                    extendObject(destination[key], source[key]);\n                } else {\n                    var bothArrays = exports.getType(destination[key]) === \"array\" && exports.getType(source[key]) === \"array\";\n                    if (bothArrays) {\n                        destination[key] = unionArrays(destination[key], source[key]);\n                    } else {\n                        destination[key] = source[key];\n                    }\n                }\n            }\n        }\n    }\n\n    function merge(obj1, obj2) {\n        var merged = {};\n        extendObject(merged, obj1);\n        extendObject(merged, obj2);\n\n        return merged;\n    }\n\n    exports.isMapped = function(viewModel) {\n        var unwrapped = ko.utils.unwrapObservable(viewModel);\n        return unwrapped && unwrapped[mappingProperty];\n    };\n\n    exports.fromJS = function(jsObject /*, inputOptions, target*/ ) {\n        if (arguments.length === 0) {\n            throw new Error(\"When calling ko.fromJS, pass the object you want to convert.\");\n        }\n        try {\n            if (!mappingNesting) {\n                dependentObservables = [];\n                visitedObjects = new ObjectLookup();\n            }\n            mappingNesting++;\n\n            var options;\n            var target;\n\n            if (arguments.length === 2) {\n                if (arguments[1][mappingProperty]) {\n                    target = arguments[1];\n                } else {\n                    options = arguments[1];\n                }\n            }\n            if (arguments.length === 3) {\n                options = arguments[1];\n                target = arguments[2];\n            }\n\n            if (target) {\n                options = merge(options, target[mappingProperty]);\n            }\n            options = fillOptions(options);\n\n            var result = updateViewModel(target, jsObject, options);\n            if (target) {\n                result = target;\n            }\n\n            // Evaluate any dependent observables that were proxied.\n            // Do this after the model's observables have been created\n            if (!--mappingNesting) {\n                while (dependentObservables.length) {\n                    var DO = dependentObservables.pop();\n                    if (DO) {\n                        DO();\n                        // Move this magic property to the underlying dependent observable\n                        DO.__DO[\"throttleEvaluation\"] = DO[\"throttleEvaluation\"];\n                    }\n                }\n            }\n\n            // Save any new mapping options in the view model, so that updateFromJS can use them later.\n            result[mappingProperty] = merge(result[mappingProperty], options);\n\n            return result;\n        } catch (e) {\n            mappingNesting = 0;\n            throw e;\n        }\n    };\n\n    exports.fromJSON = function(jsonString /*, options, target*/ ) {\n        var args = Array.prototype.slice.call(arguments, 0);\n        args[0] = ko.utils.parseJson(jsonString);\n        return exports.fromJS.apply(this, args);\n    };\n\n    exports.toJS = function(rootObject, options) {\n        if (!defaultOptions) exports.resetDefaultOptions();\n\n        if (arguments.length === 0) throw new Error(\"When calling ko.mapping.toJS, pass the object you want to convert.\");\n        if (exports.getType(defaultOptions.ignore) !== \"array\") throw new Error(\"ko.mapping.defaultOptions().ignore should be an array.\");\n        if (exports.getType(defaultOptions.include) !== \"array\") throw new Error(\"ko.mapping.defaultOptions().include should be an array.\");\n        if (exports.getType(defaultOptions.copy) !== \"array\") throw new Error(\"ko.mapping.defaultOptions().copy should be an array.\");\n\n        // Merge in the options used in fromJS\n        options = fillOptions(options, rootObject[mappingProperty]);\n\n        // We just unwrap everything at every level in the object graph\n        return exports.visitModel(rootObject, function(x) {\n            return ko.utils.unwrapObservable(x);\n        }, options);\n    };\n\n    exports.toJSON = function(rootObject, options, replacer, space) {\n        var plainJavaScriptObject = exports.toJS(rootObject, options);\n        return ko.utils.stringifyJson(plainJavaScriptObject, replacer, space);\n    };\n\n    exports.defaultOptions = function() {\n        if (arguments.length > 0) {\n            defaultOptions = arguments[0];\n        } else {\n            return defaultOptions;\n        }\n    };\n\n    exports.resetDefaultOptions = function() {\n        defaultOptions = {\n            include: _defaultOptions.include.slice(0),\n            ignore: _defaultOptions.ignore.slice(0),\n            copy: _defaultOptions.copy.slice(0),\n            observe: _defaultOptions.observe.slice(0)\n        };\n    };\n\n    exports.getType = function(x) {\n        if ((x) && (typeof(x) === \"object\")) {\n            if (x.constructor === Date) return \"date\";\n            if (x.constructor === Array) return \"array\";\n        }\n        return typeof x;\n    };\n\n    function fillOptions(rawOptions, otherOptions) {\n        var options = merge({}, rawOptions);\n\n        // Move recognized root-level properties into a root namespace\n        for (var i = recognizedRootProperties.length - 1; i >= 0; i--) {\n            var property = recognizedRootProperties[i];\n\n            // Carry on, unless this property is present\n            if (!options[property]) continue;\n\n            // Move the property into the root namespace\n            if (!(options[\"\"] instanceof Object)) options[\"\"] = {};\n            options[\"\"][property] = options[property];\n            delete options[property];\n        }\n\n        if (otherOptions) {\n            options.ignore = mergeArrays(otherOptions.ignore, options.ignore);\n            options.include = mergeArrays(otherOptions.include, options.include);\n            options.copy = mergeArrays(otherOptions.copy, options.copy);\n            options.observe = mergeArrays(otherOptions.observe, options.observe);\n        }\n        options.ignore = mergeArrays(options.ignore, defaultOptions.ignore);\n        options.include = mergeArrays(options.include, defaultOptions.include);\n        options.copy = mergeArrays(options.copy, defaultOptions.copy);\n        options.observe = mergeArrays(options.observe, defaultOptions.observe);\n\n        options.mappedProperties = options.mappedProperties || {};\n        options.copiedProperties = options.copiedProperties || {};\n        return options;\n    }\n\n    function mergeArrays(a, b) {\n        if (a === undefined) {\n            a = [];\n        } else if (exports.getType(a) !== \"array\") {\n            a = [a];\n        }\n\n        if (b === undefined) {\n            b = [];\n        } else if (exports.getType(b) !== \"array\") {\n            b = [b];\n        }\n\n        return ko.utils.arrayGetDistinctValues(a.concat(b));\n    }\n\n    // When using a 'create' callback, we proxy the dependent observable so that it doesn't immediately evaluate on creation.\n    // The reason is that the dependent observables in the user-specified callback may contain references to properties that have not been mapped yet.\n    function withProxyDependentObservable(dependentObservables, callback) {\n        var localDO = ko.dependentObservable;\n        ko.dependentObservable = function(read, owner, options) {\n            options = options || {};\n\n            if (read && typeof read === \"object\") { // mirrors condition in knockout implementation of DO's\n                options = read;\n            }\n\n            var realDeferEvaluation = options.deferEvaluation;\n            var realIsPure = options.pure;\n\n            var isRemoved = false;\n\n            // We wrap the original dependent observable so that we can remove it from the 'dependentObservables' list we need to evaluate after mapping has\n            // completed if the user already evaluated the DO themselves in the meantime.\n            var wrap = function(DO) {\n                // Temporarily revert ko.dependentObservable, since it is used in ko.isWriteableObservable\n                var tmp = ko.dependentObservable;\n                ko.dependentObservable = realKoDependentObservable;\n                var isWriteable = ko.isWriteableObservable(DO);\n                ko.dependentObservable = tmp;\n\n                var wrapped = realKoDependentObservable({\n                    read: function() {\n                        if (!isRemoved) {\n                            ko.utils.arrayRemoveItem(dependentObservables, DO);\n                            isRemoved = true;\n                        }\n                        return DO.apply(DO, arguments);\n                    },\n                    write: isWriteable && function(val) {\n                        return DO(val);\n                    },\n                    deferEvaluation: true\n                });\n                if (DEBUG) wrapped._wrapper = true;\n                wrapped.__DO = DO;\n                return wrapped;\n            };\n\n            options.deferEvaluation = true; // will either set for just options, or both read/options.\n            var realDependentObservable = realKoDependentObservable(read, owner, options);\n\n            if (!realDeferEvaluation && !realIsPure) {\n                realDependentObservable = wrap(realDependentObservable);\n                dependentObservables.push(realDependentObservable);\n            }\n\n            return realDependentObservable;\n        };\n        ko.dependentObservable.fn = realKoDependentObservable.fn;\n        ko.computed = ko.dependentObservable;\n        var result = callback();\n        ko.dependentObservable = localDO;\n        ko.computed = ko.dependentObservable;\n        return result;\n    }\n\n    function updateViewModel(mappedRootObject, rootObject, options, parentName, parent, parentPropertyName, mappedParent) {\n        var isArray = exports.getType(ko.utils.unwrapObservable(rootObject)) === \"array\";\n\n        parentPropertyName = parentPropertyName || \"\";\n\n        // If this object was already mapped previously, take the options from there and merge them with our existing ones.\n        if (exports.isMapped(mappedRootObject)) {\n            var previousMapping = ko.utils.unwrapObservable(mappedRootObject)[mappingProperty];\n            options = merge(previousMapping, options);\n        }\n\n        var callbackParams = {\n            data: rootObject,\n            parent: mappedParent || parent\n        };\n\n        var hasCreateCallback = function() {\n            return options[parentName] && options[parentName].create instanceof Function;\n        };\n\n        var createCallback = function(data) {\n            return withProxyDependentObservable(dependentObservables, function() {\n\n                if (ko.utils.unwrapObservable(parent) instanceof Array) {\n                    return options[parentName].create({\n                        data: data || callbackParams.data,\n                        parent: callbackParams.parent,\n                        skip: emptyReturn\n                    });\n                } else {\n                    return options[parentName].create({\n                        data: data || callbackParams.data,\n                        parent: callbackParams.parent\n                    });\n                }\n            });\n        };\n\n        var hasUpdateCallback = function() {\n            return options[parentName] && options[parentName].update instanceof Function;\n        };\n\n        var updateCallback = function(obj, data) {\n            var params = {\n                data: data || callbackParams.data,\n                parent: callbackParams.parent,\n                target: ko.utils.unwrapObservable(obj)\n            };\n\n            if (ko.isWriteableObservable(obj)) {\n                params.observable = obj;\n            }\n\n            return options[parentName].update(params);\n        };\n\n        var alreadyMapped = visitedObjects.get(rootObject);\n        if (alreadyMapped) {\n            return alreadyMapped;\n        }\n\n        parentName = parentName || \"\";\n\n        if (!isArray) {\n            // For atomic types, do a direct update on the observable\n            if (!canHaveProperties(rootObject)) {\n                switch (exports.getType(rootObject)) {\n                    case \"function\":\n                        if (hasUpdateCallback()) {\n                            if (ko.isWriteableObservable(rootObject)) {\n                                rootObject(updateCallback(rootObject));\n                                mappedRootObject = rootObject;\n                            } else {\n                                mappedRootObject = updateCallback(rootObject);\n                            }\n                        } else {\n                            mappedRootObject = rootObject;\n                        }\n                        break;\n                    default:\n                        if (ko.isWriteableObservable(mappedRootObject)) {\n                            var valueToWrite;\n                            if (hasUpdateCallback()) {\n                                valueToWrite = updateCallback(mappedRootObject);\n                                mappedRootObject(valueToWrite);\n                                return valueToWrite;\n                            } else {\n                                valueToWrite = ko.utils.unwrapObservable(rootObject);\n                                mappedRootObject(valueToWrite);\n                                return valueToWrite;\n                            }\n                        } else {\n                            var hasCreateOrUpdateCallback = hasCreateCallback() || hasUpdateCallback();\n\n                            if (hasCreateCallback()) {\n                                mappedRootObject = createCallback();\n                            } else {\n                                mappedRootObject = ko.observable(ko.utils.unwrapObservable(rootObject));\n                            }\n\n                            if (hasUpdateCallback()) {\n                                mappedRootObject(updateCallback(mappedRootObject));\n                            }\n\n                            if (hasCreateOrUpdateCallback) return mappedRootObject;\n                        }\n                }\n\n            } else {\n                mappedRootObject = ko.utils.unwrapObservable(mappedRootObject);\n                if (!mappedRootObject) {\n                    if (hasCreateCallback()) {\n                        var result = createCallback();\n\n                        if (hasUpdateCallback()) {\n                            result = updateCallback(result);\n                        }\n                        return result;\n                    } else {\n                        if (hasUpdateCallback()) {\n                            //Removed ambiguous parameter result\n                            return updateCallback();\n                        }\n                        mappedRootObject = {};\n                    }\n                }\n\n                if (hasUpdateCallback()) {\n                    mappedRootObject = updateCallback(mappedRootObject);\n                }\n\n                visitedObjects.save(rootObject, mappedRootObject);\n                if (hasUpdateCallback()) return mappedRootObject;\n\n                // For non-atomic types, visit all properties and update recursively\n                visitPropertiesOrArrayEntries(rootObject, function(indexer) {\n                    var fullPropertyName = parentPropertyName.length ? parentPropertyName + \".\" + escapePropertyNameComponent(indexer) : escapePropertyNameComponent(indexer);\n\n                    if (ko.utils.arrayIndexOf(options.ignore, fullPropertyName) !== -1) {\n                        return;\n                    }\n\n                    if (ko.utils.arrayIndexOf(options.copy, fullPropertyName) !== -1) {\n                        mappedRootObject[indexer] = rootObject[indexer];\n                        return;\n                    }\n\n                    if (typeof rootObject[indexer] !== \"object\" && exports.getType(rootObject[indexer]) !== \"array\" && options.observe.length > 0 && ko.utils.arrayIndexOf(options.observe, fullPropertyName) === -1) {\n                        mappedRootObject[indexer] = rootObject[indexer];\n                        options.copiedProperties[fullPropertyName] = true;\n                        return;\n                    }\n\n                    // In case we are adding an already mapped property, fill it with the previously mapped property value to prevent recursion.\n                    // If this is a property that was generated by fromJS, we should use the options specified there\n                    var prevMappedProperty = visitedObjects.get(rootObject[indexer]);\n                    var retval = updateViewModel(mappedRootObject[indexer], rootObject[indexer], options, indexer, mappedRootObject, fullPropertyName, mappedRootObject);\n                    var value = prevMappedProperty || retval;\n\n                    if (options.observe.length > 0 && ko.utils.arrayIndexOf(options.observe, fullPropertyName) === -1) {\n                        mappedRootObject[indexer] = ko.utils.unwrapObservable(value);\n                        options.copiedProperties[fullPropertyName] = true;\n                        return;\n                    }\n\n                    if (ko.isWriteableObservable(mappedRootObject[indexer])) {\n                        value = ko.utils.unwrapObservable(value);\n                        if (mappedRootObject[indexer]() !== value) {\n                            mappedRootObject[indexer](value);\n                        }\n                    } else {\n                        value = mappedRootObject[indexer] === undefined ? value : ko.utils.unwrapObservable(value);\n                        mappedRootObject[indexer] = value;\n                    }\n\n                    options.mappedProperties[fullPropertyName] = true;\n                });\n            }\n        } else { //mappedRootObject is an array\n            var changes = [];\n\n            var hasKeyCallback = false;\n            var keyCallback = function(x) {\n                return x;\n            };\n            if (options[parentName] && options[parentName].key) {\n                keyCallback = options[parentName].key;\n                hasKeyCallback = true;\n            }\n\n            if (!ko.isObservable(mappedRootObject)) {\n                // When creating the new observable array, also add a bunch of utility functions that take the 'key' of the array items into account.\n                mappedRootObject = ko.observableArray([]);\n\n                mappedRootObject.mappedRemove = function(valueOrPredicate) {\n                    var predicate = typeof valueOrPredicate === \"function\" ? valueOrPredicate : function(value) {\n                        return value === keyCallback(valueOrPredicate);\n                    };\n                    return mappedRootObject.remove(function(item) {\n                        return predicate(keyCallback(item));\n                    });\n                };\n\n                mappedRootObject.mappedRemoveAll = function(arrayOfValues) {\n                    var arrayOfKeys = filterArrayByKey(arrayOfValues, keyCallback);\n                    return mappedRootObject.remove(function(item) {\n                        return ko.utils.arrayIndexOf(arrayOfKeys, keyCallback(item)) !== -1;\n                    });\n                };\n\n                mappedRootObject.mappedDestroy = function(valueOrPredicate) {\n                    var predicate = typeof valueOrPredicate === \"function\" ? valueOrPredicate : function(value) {\n                        return value === keyCallback(valueOrPredicate);\n                    };\n                    return mappedRootObject.destroy(function(item) {\n                        return predicate(keyCallback(item));\n                    });\n                };\n\n                mappedRootObject.mappedDestroyAll = function(arrayOfValues) {\n                    var arrayOfKeys = filterArrayByKey(arrayOfValues, keyCallback);\n                    return mappedRootObject.destroy(function(item) {\n                        return ko.utils.arrayIndexOf(arrayOfKeys, keyCallback(item)) !== -1;\n                    });\n                };\n\n                mappedRootObject.mappedIndexOf = function(item) {\n                    var keys = filterArrayByKey(mappedRootObject(), keyCallback);\n                    var key = keyCallback(item);\n                    return ko.utils.arrayIndexOf(keys, key);\n                };\n\n                mappedRootObject.mappedGet = function(item) {\n                    return mappedRootObject()[mappedRootObject.mappedIndexOf(item)];\n                };\n\n                mappedRootObject.mappedCreate = function(value) {\n                    if (mappedRootObject.mappedIndexOf(value) !== -1) {\n                        throw new Error(\"There already is an object with the key that you specified.\");\n                    }\n                    var item = hasCreateCallback() ? createCallback(value) : value;\n                    if (hasUpdateCallback()) {\n                        var newValue = updateCallback(item, value);\n                        if (ko.isWriteableObservable(item)) {\n                            item(newValue);\n                        } else {\n                            item = newValue;\n                        }\n                    }\n                    mappedRootObject.push(item);\n                    return item;\n                };\n            }\n\n            var currentArrayKeys = filterArrayByKey(ko.utils.unwrapObservable(mappedRootObject), keyCallback).sort();\n            var newArrayKeys = filterArrayByKey(rootObject, keyCallback);\n            if (hasKeyCallback) newArrayKeys.sort();\n            var editScript = ko.utils.compareArrays(currentArrayKeys, newArrayKeys);\n\n            var ignoreIndexOf = {};\n\n            var i, j, key;\n\n            var unwrappedRootObject = ko.utils.unwrapObservable(rootObject);\n            var itemsByKey = {};\n            var optimizedKeys = true;\n            for (i = 0, j = unwrappedRootObject.length; i < j; i++) {\n                key = keyCallback(unwrappedRootObject[i]);\n                if (key === undefined || key instanceof Object) {\n                    optimizedKeys = false;\n                    break;\n                }\n                itemsByKey[key] = unwrappedRootObject[i];\n            }\n\n            var newContents = [];\n            var passedOver = 0;\n            var item, index;\n\n            for (i = 0, j = editScript.length; i < j; i++) {\n                key = editScript[i];\n                var mappedItem;\n                var fullPropertyName = parentPropertyName + \"[\" + escapePropertyNameComponent(i) + \"]\";\n\n                switch (key.status) {\n                    case \"added\":\n                        item = optimizedKeys ? itemsByKey[key.value] : getItemByKey(ko.utils.unwrapObservable(rootObject), key.value, keyCallback);\n                        mappedItem = updateViewModel(undefined, item, options, parentName, mappedRootObject, fullPropertyName, parent);\n                        if (!hasCreateCallback()) {\n                            mappedItem = ko.utils.unwrapObservable(mappedItem);\n                        }\n\n                        index = ignorableIndexOf(ko.utils.unwrapObservable(rootObject), item, ignoreIndexOf);\n\n                        if (mappedItem === emptyReturn) {\n                            passedOver++;\n                        } else {\n                            newContents[index - passedOver] = mappedItem;\n                        }\n\n                        ignoreIndexOf[index] = true;\n                        break;\n                    case \"retained\":\n                        item = optimizedKeys ? itemsByKey[key.value] : getItemByKey(ko.utils.unwrapObservable(rootObject), key.value, keyCallback);\n                        mappedItem = getItemByKey(mappedRootObject, key.value, keyCallback);\n                        updateViewModel(mappedItem, item, options, parentName, mappedRootObject, fullPropertyName, parent);\n\n                        index = ignorableIndexOf(ko.utils.unwrapObservable(rootObject), item, ignoreIndexOf);\n                        newContents[index] = mappedItem;\n                        ignoreIndexOf[index] = true;\n                        break;\n                    case \"deleted\":\n                        mappedItem = getItemByKey(mappedRootObject, key.value, keyCallback);\n                        break;\n                }\n\n                changes.push({\n                    event: key.status,\n                    item: mappedItem\n                });\n            }\n\n            mappedRootObject(newContents);\n\n            if (options[parentName] && options[parentName].arrayChanged) {\n                ko.utils.arrayForEach(changes, function(change) {\n                    options[parentName].arrayChanged(change.event, change.item);\n                });\n            }\n        }\n\n        return mappedRootObject;\n    }\n\n    function ignorableIndexOf(array, item, ignoreIndices) {\n        for (var i = 0, j = array.length; i < j; i++) {\n            if (ignoreIndices[i] === true) continue;\n            if (array[i] === item) return i;\n        }\n        return null;\n    }\n\n    function mapKey(item, callback) {\n        var mappedItem;\n        if (callback) mappedItem = callback(item);\n        if (exports.getType(mappedItem) === \"undefined\") mappedItem = item;\n\n        return ko.utils.unwrapObservable(mappedItem);\n    }\n\n    function getItemByKey(array, key, callback) {\n        array = ko.utils.unwrapObservable(array);\n        for (var i = 0, j = array.length; i < j; i++) {\n            var item = array[i];\n            if (mapKey(item, callback) === key) return item;\n        }\n\n        throw new Error(\"When calling ko.update*, the key '\" + key + \"' was not found!\");\n    }\n\n    function filterArrayByKey(array, callback) {\n        return ko.utils.arrayMap(ko.utils.unwrapObservable(array), function(item) {\n            if (callback) {\n                return mapKey(item, callback);\n            } else {\n                return item;\n            }\n        });\n    }\n\n    function visitPropertiesOrArrayEntries(rootObject, visitorCallback) {\n        if (exports.getType(rootObject) === \"array\") {\n            for (var i = 0; i < rootObject.length; i++)\n                visitorCallback(i);\n        } else {\n            for (var propertyName in rootObject) {\n                if (rootObject.hasOwnProperty(propertyName)) {\n                    visitorCallback(propertyName);\n                }\n            }\n        }\n    }\n\n    function canHaveProperties(object) {\n        if (object === null) {\n            return false;\n        }\n        var type = exports.getType(object);\n        return (type === \"object\") || (type === \"array\");\n    }\n\n    // Based on the parentName, this creates a fully classified name of a property\n\n    function getPropertyName(parentName, parent, indexer) {\n        var propertyName = parentName || \"\";\n        if (exports.getType(parent) === \"array\") {\n            if (parentName) {\n                propertyName += \"[\" + escapePropertyNameComponent(indexer) + \"]\";\n            }\n        } else {\n            if (parentName) {\n                propertyName += \".\";\n            }\n            propertyName += escapePropertyNameComponent(indexer);\n        }\n        return propertyName;\n    }\n\n    function escapePropertyNameComponent(indexer) {\n        var escapedIndexer = ('' + indexer)\n            .replace(/~/g, '~~')\n            .replace(/\\[/g, '~[')\n            .replace(/]/g, '~]')\n            .replace(/\\./g, '~.');\n        return escapedIndexer;\n    }\n\n\n    exports.visitModel = function(rootObject, callback, options) {\n        options = options || {};\n        options.visitedObjects = options.visitedObjects || new ObjectLookup();\n\n        var mappedRootObject;\n        var unwrappedRootObject = ko.utils.unwrapObservable(rootObject);\n\n        if (!canHaveProperties(unwrappedRootObject)) {\n            return callback(rootObject, options.parentName);\n        } else {\n            options = fillOptions(options, unwrappedRootObject[mappingProperty]);\n\n            // Only do a callback, but ignore the results\n            callback(rootObject, options.parentName);\n            mappedRootObject = exports.getType(unwrappedRootObject) === \"array\" ? [] : {};\n        }\n\n        options.visitedObjects.save(rootObject, mappedRootObject);\n\n        var parentName = options.parentName;\n        visitPropertiesOrArrayEntries(unwrappedRootObject, function(indexer) {\n            var escapedIndexer = escapePropertyNameComponent(indexer);\n            if (options.ignore && ko.utils.arrayIndexOf(options.ignore, escapedIndexer) !== -1) return;\n\n            var propertyValue = unwrappedRootObject[indexer];\n            options.parentName = getPropertyName(parentName, unwrappedRootObject, indexer);\n\n            // If we don't want to explicitly copy the unmapped property...\n            if (ko.utils.arrayIndexOf(options.copy, escapedIndexer) === -1) {\n                // ...find out if it's a property we want to explicitly include\n                if (ko.utils.arrayIndexOf(options.include, escapedIndexer) === -1) {\n                    // The mapped properties object contains all the properties that were part of the original object.\n                    // If a property does not exist, and it is not because it is part of an array (e.g. \"myProp[3]\"), then it should not be unmapped.\n                    var unwrappedRootMappingProperty = unwrappedRootObject[mappingProperty];\n                    if (unwrappedRootMappingProperty) {\n                        var mappedProperties = unwrappedRootMappingProperty.mappedProperties;\n                        if (mappedProperties && !mappedProperties[escapedIndexer]) {\n                            var copiedProperties = unwrappedRootMappingProperty.copiedProperties;\n                            if (copiedProperties && !copiedProperties[escapedIndexer] && (exports.getType(unwrappedRootObject) !== \"array\")) {\n                                return;\n                            }\n                        }\n                    }\n                }\n            }\n\n            switch (exports.getType(ko.utils.unwrapObservable(propertyValue))) {\n                case \"object\":\n                case \"array\":\n                case \"undefined\":\n                    var previouslyMappedValue = options.visitedObjects.get(propertyValue);\n                    mappedRootObject[indexer] = (exports.getType(previouslyMappedValue) !== \"undefined\") ? previouslyMappedValue : exports.visitModel(propertyValue, callback, options);\n                    break;\n                default:\n                    mappedRootObject[indexer] = callback(propertyValue, options.parentName);\n            }\n        });\n\n        return mappedRootObject;\n    };\n\n    function SimpleObjectLookup() {\n        var keys = [];\n        var values = [];\n        this.save = function(key, value) {\n            var existingIndex = ko.utils.arrayIndexOf(keys, key);\n            if (existingIndex >= 0) values[existingIndex] = value;\n            else {\n                keys.push(key);\n                values.push(value);\n            }\n        };\n        this.get = function(key) {\n            var existingIndex = ko.utils.arrayIndexOf(keys, key);\n            var value = (existingIndex >= 0) ? values[existingIndex] : undefined;\n            return value;\n        };\n    }\n\n    function ObjectLookup() {\n        var buckets = {};\n\n        var findBucket = function(key) {\n            var bucketKey;\n            try {\n                bucketKey = key; //JSON.stringify(key);\n            } catch (e) {\n                bucketKey = \"$$$\";\n            }\n\n            var bucket = buckets[bucketKey];\n            if (!buckets.hasOwnProperty(bucketKey)) {\n                bucket = new SimpleObjectLookup();\n                buckets[bucketKey] = bucket;\n            }\n            return bucket;\n        };\n\n        this.save = function(key, value) {\n            findBucket(key).save(key, value);\n        };\n        this.get = function(key) {\n            return findBucket(key).get(key);\n        };\n    }\n}));\n"]}